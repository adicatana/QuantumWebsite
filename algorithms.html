 <!DOCTYPE html>
<html lang="en">
<head>
	<title>Quantum Computing</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="bootstrap/bootstrap.min.css">
	<script src="jquery/jquery.min.js"></script>
	<script src="bootstrap/bootstrap.min.js"></script>
	<script src="latex.js"></script>
	<script src="formulas.js"></script>
	<script src="architecture.js"></script>
	<script src="algorithms.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<canvas id="background"></canvas>
	<script src="drops.js"></script>
	
	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%;" class="main">
	
	<!-- Content nav -->
		<div id="holder" class="fixeddiv"> <div class="row placeholders">
			<div href="#deutsch" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/algo1.jpg" 
						class="smallexpandable img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Deutsch's Algorithm</h4>
				</div>
			</div>
			<div  href="#title2" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar2.png" 
						class="smallexpandable  img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Classic Gates</h4>
				</div>
			</div>
			<div href="#title3" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar3.png" 
						class="smallexpandable img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Reversible Gates</h4>
				</div>
			</div>
			<div href="#title4" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar4.jpg" 
						class="smallexpandable img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Quantum Gates</h4>
				</div>
			</div>
		</div> </div>
	
	<!-- Content -->
		<h2 name="deutsch" id="deutsch">Deutsch's Algorithm</h2> <!--Quantum book exact citation-->
		<hr>

		<p> Quantum algorithms can be developed on top of a framework based on combining quantum gates. We can summarise the whole process in the following steps: </p>
		<ul>
			<li> The system starts with bits in a classical state. </li>
			<li> From there, the system is put into a superposition. </li>
			<li> The state is tranformed using unitary operations.(i.e. quantum gates) </li>
			<li> Measure the qubits, forcing them to collapse in a state.</li>
		</ul>

		<p> Notice all algorithms are probabilistic ones, not deterministic. That means, we are not guaranteed that they will work for 100% of the cases, but we do have a high probability of success. </p> 

		<br>
		<h3> The problem </h3> <!-- http://www.cs.xu.edu/~kinne/quantum/deutche.html -->

		<p id="dt1"> Suppose there is a function f that maps from {0, 1} to {0, 1}. We wish to know whether the function is injective or not.(i.e. f(0) does not equal f(1)) Opposing to the classic context, 
		one can not examine the function on different results. The main idea is to consider the gate U
		as a matrix function operator(to be visualised as a gate) applying the function f to the given
		inputs.</p>

		</p> The problem could be solved by evaluating f(0) ⊕ f(1). The xor function is the direct equivalent of asking whether f is an injection. Even though the function is evaluated twice in a classical context, the quantum context allows us to evaluate it only once. </p>

		<Breaking>
		<h3> Breaking down the problem </h3>

		<p>At the moment we know we want to obtain a superstate that will be extracted after measurement to f(0) ⊕ f(1). We only need a superstate that will be transfered to this particular point. The input is 0 and 1 along with any combination. </p>

		<p id="dt2"> Firstly, we have to keep in mind that we can process two states simultaniously. We need a matrix(gate) that gives us a state that has an equal probability to be measured as a 0 or 1. We can observ that the Hadamard gate gives us a good beahaviour:</p> 

		<p> </p>

		<p id="dt3"> Looking over the effect of the Hammond gate over the 0 and 1 states, we can observe that both bits will be driven to balaced superstates. Also, the products differ only by a sign. </p>
		<p id="dt4"></p>

		<p> </p>

		<p> At this moment, we have all the information: the input, the desired output, some means of transformations to balanced superstates, and finally, the application of function f. </p>

		<br>
		<h3> Putting the bits togeather </h3>

		<p> We will examine the circuit proposed by David Deutsch by looking at each step on the "pipeline". </p>

		<center>
		<img src="media/algop1.png" width=50%></img>
		</center>

		<p id="dt5"> The pipelineing mechanism can be expressed strictly in terms of matrices. We have 2 inputs that will be composed using the tensor product. Afterwards, each pair of binary gates will be multiplied(tensor product) so that we keep applying each matrix operator to the combined state.(4-by-1 matrix) Finally, the upper result will be measured. </p>

		<p id="dt_state1"> Let us look at the involved states step by step. Firstly, our state will be the product of the given input qubits.</p>

		<p id="dt_state2"> In the first step, we need to apply the Hadamard transformation to each of the matrices. Observe that it distributes the probabilities evenly. </p>
		
		<p id="dt_state_gen"> Observe the effect of function f over the state we have obtained. Let us study the effect of function f on the element <img src="https://latex.codecogs.com/gif.latex? \bigg[ \frac{|0\rangle - |1\rangle}{\sqrt{2}} \bigg]"></img>. We only need to apply the tensor product of the current value with the function application. More concicely,
		the function will look just as <img src="https://latex.codecogs.com/gif.latex? \bigg[ \frac{|0 \otimes f(0) \rangle - |1 \otimes f(1)\rangle}{\sqrt{2}} \bigg]"></img>.</p>

		<p id="dt_state3"> Applying the property to both elements will give two comopositions similar to the former one. Finally, we need just analiyse the outcome of the function in each case.</p>
		<p id="dt_state4"></p>
		<p id="dt_state5"> Remember that each gate is reversible, so Hadamard matrix should put its resulting state to the original input. Therefore, reappling the Hadamard matrix back will drive us into one of the initial states (0 or 1). We are particularly interested in the 0 as it will multiply to a null term after measurement. </p>
		<p id="dt_state6"></p>

		<p> Finally, measureing the top bit will give either 0, or another result. In the case the result is 0, we know that f is a constant function. </p>

		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="title2" id="title2">Title2</h2>
		<p>
			Some para
		</p>
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="title3" id="title3">Title3</h2>
		<p>
			Other para
		</p>
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="title4" id="title4">Harrow-Hasidim-Lloyd algorithm</h2>

		<p> We have now a general idea about the physical implementation, scaleability and a real-world
		theoretical example. The next step is to try to dive into the intuition behind a more complex algorithm. </p>

		<p id="hhl1"> The problem is solving a system of linear equations. In order for us to be able to model it in the quantum context, we will put it in the following form: </p>

		<p id="hhl2"> The matrix A and the vector b are known and we want to find the vector x. In the classical context this problem is well-known and its complexity is polynomial. Our main goal is to find the inverse of the matrix A. </p>

		<p> The most well known alogrithm is Gaussian elimination. The algorithms reduces the augumented matrix each line of the matrix in row echelon form. Each transition between two matrices represents adding up 2 equations. Finally, we get each element of the solution vector from bottom to top. </p>

		<p> The complexity analysis is straight forward, we iterate throught N lines, reducing O(N) in O(N) places. It is worth mentioning that in a sparse matrix(meaning the number of non-zero element in each row is much smaller than the number of element in that row), there are algorithms that run in O(N^2 log N). </p>

		<p id="hhl3">The intuitive advantage of solving the exact same problem in the quantum setting is relying on the fact that we can process multiple states at a moment. Supposing we can succesfully represent a state of size O(N) as a set of qubits, the number of necessary qubits is O(log N).</p>

		<p> Supposing we work with an exponenetial number of states, we can not naturally parse the computed result as this will slow the total speed of our algorithm from polynomial to exponential. Fortunately, we can get sufficient information about the properties of the resulting state from the eigenvalue of the observable. As an example if one has one terrabit of data in the ouput vector, we can encode the result in around 40 qubits. On the one hand, listing the resulting data will take the original size.(i.e. listing one terra of data). On the other hand, measuring the properties of the observable will give us the possibility to look at particular properties(i.e. eigenvalues) that we are interested in. </p>

		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>

	<script src="scroll.js"></script>
	<script>
		parser.staticParse(algoFormulas.fdef, 'dt1');
		parser.staticParse(algoFormulas.hadamard, 'dt2');
		parser.staticParse(algoFormulas.hexample1, 'dt3');
		parser.staticParse(algoFormulas.hexample2, 'dt4');
		parser.staticParse(algoFormulas.pipeline, 'dt5');
		parser.staticParse(algoFormulas.state1, 'dt_state1');
		parser.staticParse(algoFormulas.state0, 'dt_state2');
		parser.staticParse(algoFormulas.state2, 'dt_state3');
		parser.staticParse(algoFormulas.state3, 'dt_state4');
		parser.staticParse(algoFormulas.state4, 'dt_state5');
		parser.staticParse(algoFormulas.state5, 'dt_state6');

		parser.staticParse(algoFormulas.system, 'hhl1');
		parser.staticParse(algoFormulas.system2, 'hhl2');
		parser.staticParse(algoFormulas.hhl3, 'hhl3');
	</script>
	</div> 
</body>

</html>
 
