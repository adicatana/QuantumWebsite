 <!DOCTYPE html>
<html lang="en">
<head>
	<title>Quantum Computing</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
	<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
	<script src="sphere.js"></script>
	<script src="latex.js"></script>
	<script src="formulas.js"></script>
</head>

<body class=".col-md-3">
	<div style="margin-left:15%; margin-right:15%;">
		<h2> Bits and Qubits </h2>
		
		<p> The concept of quantum computing is a generalisation
		of classical computing, therefore the architecture of a quantum computer
		has to be based on the classical logical layout. To begin with, the corresponding 
		concept from classic computing's bit is the qubit. Following this idea, the quantum 
		gates will be manipulating quantum bits rather than bits. </p>
		
		<div class="well well-sm">
			A <b>bit</b> is a unit of information describing a classical system.
		</div>
		
		<p>
			From the list of a bit's characteristics we remind:
			<ul>
				<li>A bit holds two possible states: 0 or 1.</li>
				<li>Bits can be grouped into clustres, therefore being capable of 
				representing bigger states.</li>
				<li>Bit states can be composed by usage of logic gates.</li>
			</ul>
		</p>
		<p id="def0">
			Generalising the bit concept we shall represent the states of qubits by a 2-by-1 matrix.
		</p>
		
		<p> The main difference between a classical system is that a system can be in both states at the same time. 
		Hence, we define a qubit:</p>
		
		<div class="well well-sm" id="def1">
			A <b>quantum bit</b>(or <b>qubit</b>) is a unit of information describing a two-dimensional quantum system.
		</div>
		
		<p id="eq1">
			Interpreting the condition above, each module of the squared complex number would give a probability 
			finding the bit in the specified index quantum state. Moreover, it is easy to observe that the two bits
			are a canonical basis of our space.
		</p>
		
		<p id="eq2">
			We have already mentioned that bits are serializable, as we can represent a state just by grouping more bits. 
			The same property holds for qubits. To achieve this we use the tensor product.
		</p>
		
		<p id="eq3">
			Making a parallel with a classic byte, we know that it holds 256 states. 
			Therefore, it is a member of the set of natural numbers between 0 and 255 inclusively. 
			Simlarly, a qubyte is a member of the complex vector space of dimension 256.
		</p>
		
		<h2>
			Classic gates
		</h2>
		
		<p id="cg1">Starting with a simple gate example, a NOT gate would need to reverse the state of a qubit. 
		In order to do that, we need to find a mathematical model that can tansform a 0 qubit to a 1 qubit and
		viceversa. As both the input and the output are 2-by-1 matrices, we can simply multiply the left hand side with 
		a 2-by-2 matrix.</p>
		
		<p id="cg2">Now we can simply define a NOT gate.</p>
		<p id="cg3">The idea of using matrices as gates yelds us with much more possiblities than in a classical bit achitecture.
		For creating operation on multiple variable we need them to be serialized. For this purpose we will use the tensor product and
		for defining an operation we will use a 2-by-4 matrix. Following the same principle, gates will get bigger and bigger for composing 
		multiple operands or we can add multiple parallel gates of size 2-by-4.</p>
		
		<p id="cg4">The interesting thing is that the input has not necesarly to be a qubit, but rather any member our complex space.</p>
		
		<p id="cg5">In the classcial world the only possible states are just 1 and 0. We can simulate exactly this process, but qunatum 
		gates have more versatility. To continue with representing the classic gates let us define the OR gate.</p>
		
		<p id="cg6"> Let us take another example. We can simply see determine the form of the gate from the combinations of the output desired.
		Furtermore, the NAND gate can be decomposed in a NOT gate and an AND gate.</p>
		
		<p id="cg7"> The concept above is called perfoming <b>sequential</b> operations. We can similarly compose NOT and OR gates and so on.</p>
		
		<p id="cg8"> Also, you can observe that negating not yelds the identity matrix.</p>
		<!-- <script>
			sphere.build();
			sphere.render();
		</script> --> 
	</div>
	
	<script>
		//document.getElementById("def0").onmouseover = function () { parser.parse(archFormulas.bitdefs, 'def0' ) }; //dynamic import example
		parser.staticParse(archFormulas.bitdefs, 'def0');
		parser.staticParse(archFormulas.bitdef, 'def1');
		parser.staticParse(archFormulas.equality1, 'eq1');
		parser.staticParse(archFormulas.equality2, 'eq2');
		parser.staticParse(archFormulas.equality3, 'eq3');
		parser.staticParse(archFormulas.classic1, 'cg1');
		parser.staticParse(archFormulas.notGateDef, 'cg2');
		parser.staticParse(archFormulas.andGateDef, 'cg3');
		parser.staticParse(archFormulas.andGateEx, 'cg4');
		parser.staticParse(archFormulas.orGateDef, 'cg5');
		parser.staticParse(archFormulas.nandGateDef, 'cg6');
		parser.staticParse(archFormulas.norGateDef, 'cg7');
		parser.staticParse(archFormulas.notNot, 'cg8');
	</script>
</body>

</html>
