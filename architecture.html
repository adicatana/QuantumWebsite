 <!DOCTYPE html>
<html lang="en">
<head>
	<title>Quantum Computing</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="bootstrap/bootstrap.min.css">
	<script src="jquery/jquery.min.js"></script>
	<script src="bootstrap/bootstrap.min.js"></script>
	<script src="sphere.js"></script>
	<script src="latex.js"></script>
	<script src="formulas.js"></script>
	<script src="architecture.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
<canvas id="background"></canvas>
	<script src="drops.js"></script>
	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main even">
		<br>
		<div id="holder" class="fixeddiv"> <div class="row placeholders">
			<div href="#bits" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar1.jpg" 
						class="smallexpandable img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Bits and Qubits</h4>
				</div>
			</div>
			<div  href="#cgates" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar2.png" 
						class="smallexpandable  img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Classic Gates</h4>
				</div>
			</div>
			<div href="#rgates" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar3.png" 
						class="smallexpandable img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Reversible Gates</h4>
				</div>
			</div>
			<div href="#qgates" class="scroller" align="center">
				<div class="col-xs-6 col-sm-3 placeholder" align="center">
					<img src="media/ar4.jpg" 
						class="smallexpandable img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Quantum Gates</h4>
				</div>
			</div>
		</div> </div>
	</div>

	<br>
	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main odd">
		<br>
		<div class="row">
			<div class="col-sm-10"> <h2 name="bits" id="bits"> Bits and Qubits </h2> </div>
			<div class="col-sm-2" style="margin-top: 10px"> 
				<a class="btn btn-default btn-lg" href="index.php?Videos=true">See Video &raquo;</a>
			</div>
		</div>
		<br>

		<p> The concept of quantum computing is a generalisation
		of classical computing, therefore the architecture of a quantum computer
		has to be based on the classical logical layout. To begin with, the corresponding 
		concept from classic computing's bit is the qubit. Following this idea, the quantum 
		gates will be manipulating quantum bits rather than bits. </p>
		
		<div class="well well-sm wellodd">
			A <b><i>bit</i></b> is a unit of information describing a classical system.
		</div>
		
		<p>
			From the bit's characteristics list we remind:
			<sup><a href="index.php?References=true#b1" class="ref">[1]</a></sup>
			<ul>
				<li>A bit holds two possible states: 0 or 1.</li>
				<li>Bits can be grouped into clusters, therefore being capable of 
				representing bigger states.</li>
				<li>Bit states can be composed by usage of logic gates.</li>
			</ul>
		</p>
		<p id="def0">
			Generalising the bit concept we shall represent the states of qubits by a 2-by-1 matrix.
		</p>
		
		<p> The main difference between a classical system is that a system can be in both states at the same time. 
		Hence, we define a qubit:</p>
		
		<div class="well well-sm wellodd" id="def1">
			A <b><i>quantum bit</i></b> (or <i><b>qubit</b></i>) is a unit of information describing a two-dimensional quantum system.
		</div>
		
		<p id="eq1">
			Interpreting the condition above, each module of the squared complex number would give a probability 
			finding the bit in the specified index quantum state. Moreover, it is easy to observe that the two bits
			are a canonical basis of our space.
		</p>
		
		<p id="eq2">
			We have already mentioned that bits are serializable, as we can represent a state just by grouping more bits. 
			The same property holds for qubits. To achieve this we use the tensor product.
		</p>
		
		<p id="eq3">
			Making a parallel with a classic byte, we know that it holds 256 states. 
			Therefore, it is a member of the set of natural numbers between 0 and 255 inclusively. 
			Similarly, a qubyte is a member of the complex vector space of dimension 256.
			<sup><a href="index.php?References=true#b2" class="ref">[2]</a></sup>
		</p>
		
		<div align="center" href="#holder" class="scroller">
			<img src="media/up.png" width=25></img>
			<p> Go to top </p>
		</div>
	</div>

	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main even">
		<br>
		<div class="row">
			<div class="col-sm-10">
				<h2 name="cgates" id="cgates"> <!-- Quantum book & Gates book -->
					Classic Gates
				</h2>
			</div>
			<div class="col-sm-2" style="margin-top: 10px"> 
				<a class="btn btn-default btn-lg" href="index.php?Videos=true">See Video &raquo;</a>
			</div>
		</div>
		<br>
		
		<p id="cg1">Starting with a simple gate example, a <b>NOT</b> gate would need to reverse the state of a qubit. 
		In order to do that, we need to find a mathematical model that can transform a 0 qubit to a 1 qubit and
		vice versa. As both the input and the output are 2-by-1 matrices, we can simply multiply the left hand side with 
		a 2-by-2 matrix.</p>
		
		<p id="cg2">Now we can simply define a <b>NOT</b> gate.</p>
		<p id="cg3">The idea of using matrices as gates yields us with much more possibilities than in a classical bit architecture.
		For creating operation on multiple variable we need them to be serialized. For this purpose we will use the tensor product and
		for defining an operation we will use a 2-by-4 matrix. Following the same principle, gates will get bigger and bigger for composing 
		multiple operands or we can add multiple parallel gates of size 2-by-4.</p>
		
		<p id="cg4">The interesting thing is that the input has not necessarily to be a qubit, but rather any member our complex space. <sup><a href="index.php?References=true#b3" class="ref">[3]</a></sup></p>
		
		<p id="cg5">In the classical world the only possible states are just 1 and 0. We can simulate exactly this process, but quantum 
		gates have more versatility. To continue with representing the classic gates let us define the <b>OR</b> gate.</p>
		
		<p id="cg6"> Let us take another example. We can simply see determine the form of the gate from the combinations of the output desired.
		Furthermore, the <b>NAND</b> gate can be decomposed in a <b>NOT</b> gate and an <b>AND</b> gate.</p>
		
		<p id="cg7"> The concept above is called performing <b>sequential</b> operations. We can similarly compose <b>NOT</b> and <b>OR</b> gates and so on.</p>
		
		<p id="cg8"> Also, you can observe that negating not yields the identity matrix.</p>
		
		<p id="cg9"> We saw that tensor product can compose two qubits, the result being modeled using binary input gates such as <b>AND</b>. 
		This principle can be extended for multiple input gates. Consider we want to process 3 qubits at the same time, to negate the 
		first qubit and apply nor operation on the other two. </p>
		
		<p id="cg10"> Furthermore, we can serialize the below outputs with another gate, say <b>OR</b>.
		</p>
		
		<div align="center" href="#holder" class="scroller">
			<img src="media/up.png" width=25></img>
			<p> Go to top </p>
		</div>
	</div>

	<br>
	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main odd">
		<br>
	
		<div class="row">
			<div class="col-sm-10">
				<h2 name="rgates" id="rgates"> Reversible Gates </h2>
			</div>
			<div class="col-sm-2" style="margin-top: 10px"> 
				<a class="btn btn-default btn-lg" href="index.php?Videos=true">See Video &raquo;</a>
			</div>
		</div>

		<br>
			<p> It can be easily seen that a part of the gates we discussed are reversible. A gate is <b><i>reversible</i></b> if the output applied to its 
			results is the input. The concept might be intuitive as one can tell that when <b>AND</b> operation is applied as above, we can not exactly determine 
			which of the three possible inputs yield the result 0. On the other hand, a <b>NOT</b> get will give an unique result with multiplication.</p>
			
			<p> Before presenting the most frequent reversible gates, we will begin with a simple example: the controlled-<b>NOT</b> gate. The idea is
			simple: we have two inputs, the control qubit is being preserved and the input qubit will be negated if the control qubit is 1. </p>
			
			<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/CNOT_gate.svg/300px-CNOT_gate.svg.png">
			<p>Picture illustrating the controlled-NOT gate<sup><a href="index.php?References=true#picture1" class="ref">[46]</a></sup></p>
			<br>
			<p id="rg1"> By examining the gate's matrix form we can easily observe that the gate is reversible.</p>
			
			<p> A more common example is the <b>Toffoli gate</b>. This is a gate that has a similar structure to the <b>CNOT</b> gate, but it has two
			control inputs. If both control inputs are switched on, then the result is negated. </p>
			
			<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Toffoli_gate.svg/225px-Toffoli_gate.svg.png">
			<p>Picture illustrating the Toffoli gate<sup><a href="index.php?References=true#picture2" class="ref">[47]</a></sup></p>
			<br>
			<p id="rg2"> We can visualize in a simpler way the effect of the <b>Toffoli gate</b> by keeping in mind the following state transformation:</p>
			
			<p> An important property of the <b>Toffoli gate</b> is the face that is universal.</p>
			
			<div class="well well-sm wellodd">
				A gate is <b><i>universal</i></b> if any classic gate can be built using just the mentioned gate.
			</div>
			
			<p id="rg3"> It is well known that the <b>NAND</b> gate is universal as if can act as a <b>NOT</b> gate if we fix one of the inputs as 1. We can after 
			that build a <b>AND</b> gate by <b>NAND</b> and <b>NOT</b>. Applying <i><b>De Morgan's Law</b></i> we can build a <b>OR</b> gate from the <b>AND</b> with 3 <b>NOT</b>s. The rest of the
			gates can be trivial. Reasoning in a similar way, we want to obtain a <b>AND</b> gate and a <b>NOT</b> gate. The <b>NOT</b> gate is trivial as one 
			can fix both controllers to 1. The <b>AND</b> gate can be made by setting the input to 0. This can be again easily represented as state
			transformations. <sup><a href="index.php?References=true#b4" class="ref">[4]</a></sup> </p>
			
			<p id="rg4"> As expected, the <b>Toffoli gate</b> can be written in matrix form. The size of the matrix will be 8 as we have 3 inputs. <sup><a href="index.php?References=true#b8" class="ref">[8]</a></sup> </p>
			
			<p id="rg5"> The last example will be the <b>Fredkin gate</b>. The gate has also 3 inputs, the first being a controller. If the controller is 0, 
			the other two inputs remain the same, otherwise they will be swapped. This gate is also universal and representable as a matrix.
			We leave these as an exercise for the reader.</p>
			
			<br>
			<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Fredkin_gate.svg/225px-Fredkin_gate.svg.png">
			<p>Picture illustrating the Fredkin gate<sup><a href="index.php?References=true#picture3" class="ref">[48]</a></sup></p>
			<br>
			
			<div align="center" href="#holder" class="scroller">
				<img src="media/up.png" width=25></img>
				<p> Go to top </p>
			</div>
		</div>	
	</div>

	<br>
	<div style="margin-bottom: 50px; margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main even">

		<br>
		<h2 name="qgates" id="qgates"> Quantum gates </h2>
		<br>

		<div class="well well-sm welleven">
			A <b><i>quantum gate</i></b> is a gate that operates on qubits.
		</div>
			
		<p> We can represent a quantum gate as a unitary matrix. As a reminder, a unitary matrix is a complex square matrix 
		which has its conjugate transpose equal to its inverse. One can observe that the gates mentioned in the previous section are unitary,
		therefore can be used also as quantum gates. Provided that a state is quite versatile one can think that there are many possibilities
		for a single state to be manipulated. We do not know at each step if a qubit is 0 or 1, but after measuring we can tell exactly. 
		Therefore, we need a simple way to think of a single state as we move on.</p>
			
		<p id="qg1"> Complex numbers are particularly nice to reason with as they can be represented as 
		two dimensional vectors. If we fix their 
		module they can be represented as fixed vectors on a circle. The fact that our states are bounded 
		by a similar constraint makes
		us thinking of a similar representation.</p>
			
		<p> We can represent the state as a dependency of two angles. The representation is 
		called the <b>Bloch sphere</b>. The standard parameterization of the bloch sphere is decomposes <i>x, y</i> and 
		<i>z</i> by the angel formed between the vector and the plane <i>x - y</i> - usually denoted with <i><b>theta</b></i> - and the
		angle between the projection and <i>x</i>. As a parallel to mapping, theta is called azimuthal (being 
		proportional to the the length of the "parallels") angle and <i><b>phi</b></i> is called polar angle (fixing the 
		place of the "meridians"). <sup><a href="index.php?References=true#b5" class="ref">[5]</a></sup> </p>
		<center><p id="bloch1"><i>Move the cursor over the image to see the polar and azimuthal angles.</i>
		 </p></center>

		<p>The uses of the <i><b>Bloch sphere</b></i> are mainly manipulation of a single qubit using a 2-
		by-2 matrix. Consider a reflection around the axis Z. The mathematical model is not that 
		intuitive, thus we can use the Bloch representation. <sup><a href="index.php?References=true#b6" class="ref">[6]</a></sup> </p>
		<center><p id="bloch2"><i>Click on the image to see the reflection of a point around the axis Z.</i>
		 </p> </center>

		<p>The mechanism is quite versatile as we can build matrices to make rotations around 
		the axes. This matrices are called the <b><i>Pauli</i></b> matrices and each are designed to make a full 
		rotation around each of the axes. We can simply illustrate a 180 degree rotation of the <i><b>bloch 
		sphere</b></i> around axis <i>Y</i>. <sup><a href="index.php?References=true#b7" class="ref">[7]</a></sup><center> </p>
		<p id="bloch3"><i>Click on the image to see the rotation of the <b>Bloch sphere</b> around the axis Y.</i>
		 </p></center>

		<p id="qg2"> The above bloch sphere shows the effect of the Y <b>Pauli matrix</b>. To fully understand 
		its effect let us take a look over the <b>Pauli</b> matrices. One can observe that a rotation around X
		would simply reverse the 0 qubit, therefore the X matrix is exactly the <b>NOT</b> matrix. Intuitively, 
		rotating around the Y axes should give us a similar result, but there is more than one azimuthal 
		angle at the poles. </p>
		
		<p id="qg3">The <b>Pauli</b> gates can be parameterized, obtaining any rotation on each of the axes. Those instruments are very powerful as one can alter a qubit easily. Let us exemplify the process of parameterization on the X axis.</p>
			
		<p id="qg4">Making use of the tensor product will allow this changes to be controlled by different qubits.
		There are more similar examples with more controllers such as <b>Deutsch</b> gate.</p>

		<p>Even though we have powerful instruments used for manipulation of a qubit, the major drawback is the lack of coverage over a cluster of bits and the entanglement. Even more, each operation on a quantum gate must be reversible and the <i><b>No-Cloning Theorem</b></i> must hold (it is impossible to clone an arbitrary quantum state without destroying the original).<sup><a href="index.php?References=true#b9" class="ref">[9]</a></sup></p>

		<div align="center" href="#holder" class="scroller">
			<img src="media/up.png" width=25></img>
			<p> Go to top </p>
		</div>
	</div>
	</div>
	<script>
		//document.getElementById("def0").onmouseover = function () { parser.parse(archFormulas.bitdefs, 'def0' ) }; //dynamic import example
		window.onload = function() {
		  parser.staticParse(archFormulas.bitdefs, 'def0');
		  parser.staticParse(archFormulas.bitdef, 'def1');
		  parser.staticParse(archFormulas.equality1, 'eq1');
		  parser.staticParse(archFormulas.equality2, 'eq2');
		  parser.staticParse(archFormulas.equality3, 'eq3');
		  
		  parser.staticParse(archFormulas.classic1, 'cg1');
		  parser.staticParse(archFormulas.notGateDef, 'cg2');
		  parser.staticParse(archFormulas.andGateDef, 'cg3');
		  parser.staticParse(archFormulas.andGateEx, 'cg4');
		  parser.staticParse(archFormulas.orGateDef, 'cg5');
		  parser.staticParse(archFormulas.nandGateDef, 'cg6');
		  parser.staticParse(archFormulas.norGateDef, 'cg7');
		  parser.staticParse(archFormulas.notNot, 'cg8');
		  parser.staticParse(archFormulas.classic2, 'cg9');
		  parser.staticParse(archFormulas.classic3, 'cg10');
		  
		  parser.staticParse(archFormulas.cnotCnot, 'rg1');
		  parser.staticParse(archFormulas.toffli, 'rg2');
		  parser.staticParse(archFormulas.toffliUni, 'rg3');
		  parser.staticParse(archFormulas.toffliDef, 'rg4');
		  parser.staticParse(archFormulas.fredkin, 'rg5');
		  
		  parser.staticParse(archFormulas.equality1, 'qg1');
		  parser.staticParse(archFormulas.pauli, 'qg2');
		  parser.staticParse(archFormulas.xp, 'qg3');
		  parser.staticParse(archFormulas.cu, 'qg4');
		  
		  spheres.dynamicSphere.build("bloch1");
		  spheres.dynamicSphere.render();
		  
		  spheres.refXSphere.build("bloch2");
		  spheres.refXSphere.render();
		  
		  spheres.rotYSphere.build("bloch3");
		  spheres.rotYSphere.render();
		}
	</script>
	
	<script src="scroll.js"></script>
</body>

</html>
