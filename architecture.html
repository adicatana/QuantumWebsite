 <!DOCTYPE html>
<html lang="en">
<head>
	<title>Quantum Computing</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
	<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"></script>
	<script src="sphere.js"></script>
	<script src="latex.js"></script>
	<script src="formulas.js"></script>
	<script src="architecture.js"></script>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<canvas id="background"></canvas>
	<script src="drops.js"></script>
	
	<div style="margin-left:10%; margin-right:10%; padding-left:5%; padding-right:5%" class="main">
		<div id="holder"> <div class="row placeholders">
			<div href="#bits" class="scroller">
				<div class="col-xs-6 col-sm-3 placeholder">
					<img src="http://scottkantner.com/wp-content/uploads/2011/09/bits-and-bytes_key1.jpg" 
						width="200" height="200" 
						class="img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Bits and Qubits</h4>
				</div>
			</div>
			<div  href="#cgates" class="scroller">
				<div class="col-xs-6 col-sm-3 placeholder">
					<img src="http://www.schoolphysics.co.uk/age16-19/Electronics/Logic%20gates/text/Logic_gates/images/2.png" 
						width="200" 
						height="200" 
						class="img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Classic Gates</h4>
				</div>
			</div>
			<div href="#rgates" class="scroller">
				<div class="col-xs-6 col-sm-3 placeholder">
					<img src="http://2.bp.blogspot.com/-E5-mySF-R4c/TjWJ-IPnyDI/AAAAAAAAMJo/eW8lyIhzjHw/s1600/reversibleALU.png" 
						width="200" height="200" 
						class="img-circle" 
						alt="Generic placeholder thumbnail">
					<h4>Reversible Gates</h4>
				</div>
			</div>
			<div href="#qgates" class="scroller">
				<div class="col-xs-6 col-sm-3 placeholder">
					<img src="http://www.nature.com/ncomms/journal/v3/n8/images/ncomms2003-f2.jpg" 
						width="200" 
						height="200" 
						class="img-circle"  
						alt="Generic placeholder thumbnail">
					<h4>Quantum Gates</h4>
				</div>
			</div>
		</div> </div>
		
		<h2 name="bits" id="bits"> Bits and Qubits </h2> <!-- Quantum book -->
		
		<p> The concept of quantum computing is a generalisation
		of classical computing, therefore the architecture of a quantum computer
		has to be based on the classical logical layout. To begin with, the corresponding 
		concept from classic computing's bit is the qubit. Following this idea, the quantum 
		gates will be manipulating quantum bits rather than bits. </p>
		
		<div class="well well-sm">
			A <b>bit</b> is a unit of information describing a classical system.
		</div>
		
		<p>
			From the list of a bit's characteristics we remind:
			<ul>
				<li>A bit holds two possible states: 0 or 1.</li>
				<li>Bits can be grouped into clustres, therefore being capable of 
				representing bigger states.</li>
				<li>Bit states can be composed by usage of logic gates.</li>
			</ul>
		</p>
		<p id="def0">
			Generalising the bit concept we shall represent the states of qubits by a 2-by-1 matrix.
		</p>
		
		<p> The main difference between a classical system is that a system can be in both states at the same time. 
		Hence, we define a qubit:</p>
		
		<div class="well well-sm" id="def1">
			A <b>quantum bit</b>(or <b>qubit</b>) is a unit of information describing a two-dimensional quantum system.
		</div>
		
		<p id="eq1">
			Interpreting the condition above, each module of the squared complex number would give a probability 
			finding the bit in the specified index quantum state. Moreover, it is easy to observe that the two bits
			are a canonical basis of our space.
		</p>
		
		<p id="eq2">
			We have already mentioned that bits are serializable, as we can represent a state just by grouping more bits. 
			The same property holds for qubits. To achieve this we use the tensor product.
		</p>
		
		<p id="eq3">
			Making a parallel with a classic byte, we know that it holds 256 states. 
			Therefore, it is a member of the set of natural numbers between 0 and 255 inclusively. 
			Simlarly, a qubyte is a member of the complex vector space of dimension 256.
		</p>
		
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="cgates" id="cgates"> <!-- Quantum book & Gates book -->
			Classic Gates
		</h2>
		
		<p id="cg1">Starting with a simple gate example, a NOT gate would need to reverse the state of a qubit. 
		In order to do that, we need to find a mathematical model that can tansform a 0 qubit to a 1 qubit and
		viceversa. As both the input and the output are 2-by-1 matrices, we can simply multiply the left hand side with 
		a 2-by-2 matrix.</p>
		
		<p id="cg2">Now we can simply define a NOT gate.</p>
		<p id="cg3">The idea of using matrices as gates yelds us with much more possiblities than in a classical bit achitecture.
		For creating operation on multiple variable we need them to be serialized. For this purpose we will use the tensor product and
		for defining an operation we will use a 2-by-4 matrix. Following the same principle, gates will get bigger and bigger for composing 
		multiple operands or we can add multiple parallel gates of size 2-by-4.</p>
		
		<p id="cg4">The interesting thing is that the input has not necesarly to be a qubit, but rather any member our complex space.</p>
		
		<p id="cg5">In the classcial world the only possible states are just 1 and 0. We can simulate exactly this process, but qunatum 
		gates have more versatility. To continue with representing the classic gates let us define the OR gate.</p>
		
		<p id="cg6"> Let us take another example. We can simply see determine the form of the gate from the combinations of the output desired.
		Furtermore, the NAND gate can be decomposed in a NOT gate and an AND gate.</p>
		
		<p id="cg7"> The concept above is called perfoming <b>sequential</b> operations. We can similarly compose NOT and OR gates and so on.</p>
		
		<p id="cg8"> Also, you can observe that negating not yelds the identity matrix.</p>
		
		<p id="cg9"> We saw that tensor product can compose two qubits, the result being modeled using binary input gates such as AND. 
		This principle can be extended for multiple input gates. Consider we want to process 3 qubits at the same time, to negate the 
		first qubit and apply nor operation on the other two. </p>
		
		<p id="cg10"> Furthermore, we can serialize the below outputs with another gate, say OR.
		</p>
		
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="rgates" id="rgates"> Reversible Gates </h2> <!-- Quantum book & Gates wiki -->
		
		<p> It can be easily seen that a part of the gates we discussed are reversible. A gate is <b>reversible</b> if the output applied to its 
		results is the input. The concept might be intuitive as one can tell that when AND operation is applied as above, we can not exacly determine 
		which of the three possible inputs yeld the result 0. On the other hand, a NOT get will give an unique result with multiplication. </p>
		
		<p> Before presenting the most frequent reversible gates, we will begin with a simple example: the controlled-NOT gate. The idea is
		simple: we have two inputs, the control qubit is being preseverd and the input qubit will be negated if the control qubit is 1. </p>
		
		<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/CNOT_gate.svg/300px-CNOT_gate.svg.png">
		
		<p id="rg1"> By examining the gate's matrix form we can easily observe that the gate is reversible.</p>
		
		<p> A more common example is the <b>Toffli gate</b>. This is a gate that has a similar structure to the CNOT gate, but it has two
		control inputs. If both control inputs are switched on, then the result is negated. </p>
		
		<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Toffoli_gate.svg/225px-Toffoli_gate.svg.png">
		
		<p id="rg2"> We can visualize in a simpler way the effect of the Toffli gate by keeping in mind the following state transformation:</p>
		
		<p> An important property of the Toffli gate is the face that is universal.</p>
		
		<div class="well well-sm">
			A gate is <b>universal</b> if any classic gate can be built using just the mentioned gate.
		</div>
		
		<p id="rg3"> It is well known that the NAND gate is universal as if can act as a NOT gate if we fix one of the inputs as 1. We can after 
		that build a AND gate by NAND and NOT. Applying De Morgan's Law we can build a OR gate from the AND with 3 NOTs. The rest of the
		gates can be trivial. Reasoning in a similar way, we want to obtain a AND gate and a NOT gate. The NOT gate is trivial as one 
		can fix both controllers to 1. The AND gate can be made by setting the input to 0. This can be again easily represeted as state
		transformations. </p>
		
		<p id="rg4"> As expected, the Toffli gate can be written in matrix form. The size of the matrix will be 8 as we have 3 inputs.</p>
		
		<p id="rg5"> The last example will be the Fradkin gate. The gate has also 3 inputs, the first being a controller. If the controler is 0, 
		the other two inputs remain the same, otherwise they will be swaped. This gate is also universal and representable as a matrix.
		We leave these as an exercise for the reader.</p>
		
		<br>
		<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Fredkin_gate.svg/225px-Fredkin_gate.svg.png">
		
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
		
		<h2 name="qgates" id="qgates"> Quantum gates </h2>
		
		<div class="well well-sm">
			A <b>quantum gate</b> is a gate that operates on qubits.
		</div>
		
		<p> We can represent a qunatum gate as a unitary matrix. As a reminder, a unitary matrix is a complex square matrix 
		which has its conjugate transpose equal to its inverse. One can observe that the gates mentioned in the previous section are unitary,
		therefore can be used also as quantum gates. Provided that a state is quite versatile one can think that there are many possiblities
		for a single state to be manipulated. We do not know at each step if a qubit is 0 or 1, but after measuring we can tell exactly. 
		Therefore, we need a simple way to think of a single state as we move on.</p>
		
		<p id="qg1"> Complex numbers are particularly nice to reason with as they can be represented as two dimensional vectors. If we fix their 
		module they can be represented as fixed vectors on a circle. The fact that our states are bounded by a similar constraint makes
		us thinking of a similar representation.</p>
		
		<p id="bloch1"> We can represent the state as a dependency of two angles. The representation is called the Bloch sphere. The standard parametrization of the bloch sphere is decomposes x, y and z by the angel formed between the vector and the plane x-y - usually denoted with theta - and the
		angle between the projection and x. As a parallel to mapping, theta is called azimuthal(being proportional to the the length of the "parallels") angle and phi is called polar angle(fixing the place of the "merdians").  </p>

		<p id="bloch2">The uses of the Bloch sphere are manily manipulation of a single qubit using a 2-by-2 matrix. Consider a reflection around the axis Z. The mathematical model is not that intutive, thus we can use the Bloch representation.</p>

		<p id="bloch3">The mechanism is quite versatile as we can build matrices to make roations around the axes. This matrices are called the Pauli matrices and each are designed to make a full rotation around each of the axes. We can simply illustrate a 180 degree rotation of the bloch sphere around axes Y.</p>

		<p id="qg2"> The above bloch sphere shows the effect of the Y Pauli matrix. To fully understand its effect let us take a look over the Pauli matrices.</p>
		
		<div align="center" href="#holder" class="scroller">
			<span class="glyphicon glyphicon-chevron-up" > </span>
			<p> Go to contents </p>
		</div>
	</div>
	<script>
		//document.getElementById("def0").onmouseover = function () { parser.parse(archFormulas.bitdefs, 'def0' ) }; //dynamic import example
		window.onload = function() {
		  parser.staticParse(archFormulas.bitdefs, 'def0');
		  parser.staticParse(archFormulas.bitdef, 'def1');
		  parser.staticParse(archFormulas.equality1, 'eq1');
		  parser.staticParse(archFormulas.equality2, 'eq2');
		  parser.staticParse(archFormulas.equality3, 'eq3');
		  
		  parser.staticParse(archFormulas.classic1, 'cg1');
		  parser.staticParse(archFormulas.notGateDef, 'cg2');
		  parser.staticParse(archFormulas.andGateDef, 'cg3');
		  parser.staticParse(archFormulas.andGateEx, 'cg4');
		  parser.staticParse(archFormulas.orGateDef, 'cg5');
		  parser.staticParse(archFormulas.nandGateDef, 'cg6');
		  parser.staticParse(archFormulas.norGateDef, 'cg7');
		  parser.staticParse(archFormulas.notNot, 'cg8');
		  parser.staticParse(archFormulas.classic2, 'cg9');
		  parser.staticParse(archFormulas.classic3, 'cg10');
		  
		  parser.staticParse(archFormulas.cnotCnot, 'rg1');
		  parser.staticParse(archFormulas.toffli, 'rg2');
		  parser.staticParse(archFormulas.toffliUni, 'rg3');
		  parser.staticParse(archFormulas.toffliDef, 'rg4');
		  parser.staticParse(archFormulas.fredkin, 'rg5');
		  
		  parser.staticParse(archFormulas.equality1, 'qg1');
		  parser.staticParse(archFormulas.pauli, 'qg2');
		  
		  spheres.dynamicSphere.build("bloch1");
		  spheres.dynamicSphere.render();
		  
		  spheres.refXSphere.build("bloch2");
		  spheres.refXSphere.render();
		  
		  spheres.rotYSphere.build("bloch3");
		  spheres.rotYSphere.render();
		}
	</script>
	
	<script src="scroll.js"></script>
</body>

</html>
